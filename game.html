<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>World Domination 3D - Mega Boss Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; transition: background-color 0.5s; background: #87ceeb; touch-action: none; }
        body.dark-mode { background: #0a0a14; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 28px; height: 28px; border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 5; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; opacity: 0.5; }
        #crosshair::before { top: 50%; left: -5px; width: 10px; height: 2px; }
        #crosshair::after { left: 50%; top: -5px; height: 10px; width: 2px; }
        #crosshair.locked { border-color: #ff3333 !important; transform: translate(-50%, -50%) scale(1.1); }
        
        #damage-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; border: 0px solid rgba(239, 68, 68, 0); transition: border 0.1s; pointer-events: none; z-index: 10; }
        .modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 40px; border-radius: 12px; text-align: center; display: none; color: white; border: 1px solid rgba(255,255,255,0.1); pointer-events: all; z-index: 100; width: 90%; max-width: 450px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); }
        
        #joystick-wrapper { position: fixed; bottom: 40px; left: 40px; width: 130px; height: 130px; background: rgba(0,0,0,0.1); border-radius: 50%; z-index: 50; display: none; touch-action: none; border: 2px solid rgba(0,0,0,0.1); }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: #fff; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        
        .mobile-btn { position: fixed; bottom: 40px; right: 40px; width: 85px; height: 85px; background: rgba(0,0,0,0.1); border-radius: 50%; z-index: 50; display: none; align-items: center; justify-content: center; color: white; font-weight: 900; border: 1px solid rgba(255,255,255,0.2); text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        #turbo-btn { bottom: 140px; right: 40px; width: 65px; height: 65px; font-size: 10px; background: rgba(239, 68, 68, 0.4); }
        #exit-btn { bottom: 220px; right: 40px; width: 65px; height: 65px; font-size: 10px; background: rgba(59, 130, 246, 0.4); display: none; }
        
        #start-screen { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200; color: white; cursor: pointer; }
        #turbo-indicator { position: fixed; top: 90px; left: 50%; transform: translateX(-50%); padding: 4px 12px; border-radius: 4px; background: #ff3333; color: white; font-size: 11px; font-weight: 900; display: none; z-index: 60; }
        
        #boss-ui { position: fixed; top: 90px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 600px; display: none; z-index: 15; flex-direction: column; align-items: center; gap: 4px; }

        @media (max-width: 768px) { #joystick-wrapper, .mobile-btn { display: flex; } }
    </style>
</head>
<body class="light-mode">

    <div id="damage-overlay"></div>
    <div id="turbo-indicator">AUTO-FIRE ACTIVE</div>

    <!-- Boss Health UI -->
    <div id="boss-ui">
        <span class="text-[10px] text-red-600 font-black tracking-widest uppercase">Mega Boss: Command Alpha</span>
        <div class="w-full h-3 bg-red-950/40 rounded-full border border-red-500/30 overflow-hidden shadow-[0_0_15px_rgba(239,68,68,0.2)]">
            <div id="bossHealthBar" class="h-full bg-red-600 transition-all duration-300" style="width: 100%"></div>
        </div>
    </div>

    <div id="joystick-wrapper"><div id="joystick-knob"></div></div>
    <div id="fire-btn" class="mobile-btn">FIRE</div>
    <div id="turbo-btn" class="mobile-btn">TURBO</div>
    <div id="exit-btn" class="mobile-btn">EXIT</div>

    <canvas id="minimap" width="140" height="140" class="fixed bottom-4 right-4 bg-black/40 backdrop-blur-md border border-white/10 rounded-lg z-10 pointer-events-none"></canvas>

    <div id="start-screen" onclick="startGame()">
        <div class="mb-4 text-orange-500 font-bold tracking-[0.3em] text-sm animate-pulse uppercase">Tactical Alert</div>
        <h1 class="text-6xl font-black italic tracking-tighter mb-4 text-white uppercase">World Domination</h1>
        <p class="text-xl opacity-60 mb-12 uppercase tracking-[0.2em]">Deployment Ready. Click to Engage.</p>
    </div>

    <!-- HUD -->
    <div id="top-bar" class="fixed top-0 left-0 w-full h-20 bg-black/40 backdrop-blur-xl border-b border-white/5 flex items-center px-8 justify-between text-white z-20 pointer-events-none transition-all duration-500">
        <div class="flex items-center gap-8">
            <div class="flex items-center gap-2 pointer-events-auto">
                <button onclick="toggleTheme()" class="bg-white/10 hover:bg-white/20 p-2 rounded-full border border-white/20 transition-all active:scale-90">
                    <span id="theme-icon" class="text-xl">‚òÄÔ∏è</span>
                </button>
                <div class="flex flex-col">
                    <span class="text-[9px] uppercase font-bold text-orange-400 leading-none tracking-widest mb-1">Clearance</span>
                    <span id="rank" class="text-xl font-black italic uppercase tracking-tight">SOLDIER</span>
                </div>
            </div>
            
            <div class="flex flex-col">
                <span class="text-[9px] uppercase font-bold text-red-500 leading-none tracking-widest mb-1">Reserves</span>
                <div id="lives-display" class="flex gap-1 text-lg">
                    <span id="h1">‚ù§Ô∏è</span><span id="h2">‚ù§Ô∏è</span><span id="h3">‚ù§Ô∏è</span>
                </div>
            </div>
            <div class="flex flex-col">
                <span class="text-[9px] uppercase font-bold text-gray-400 leading-none tracking-widest mb-1">Status</span>
                <span id="weapon-name" class="text-sm font-bold text-white/80 tracking-tighter uppercase">Rifle</span>
            </div>
        </div>

        <div class="flex flex-col items-center w-1/4 max-w-sm pointer-events-auto gap-2">
            <div class="w-full">
                <div class="flex justify-between w-full text-[9px] uppercase font-black mb-1 tracking-wider">
                    <span>Structural Integrity</span>
                    <span id="hpText">100%</span>
                </div>
                <div class="w-full h-1.5 bg-white/5 rounded-full overflow-hidden">
                    <div id="healthBar" class="h-full bg-orange-500 transition-all duration-300" style="width: 100%"></div>
                </div>
            </div>
            <div class="w-full h-1 bg-white/5 rounded-full overflow-hidden">
                <div id="xpBar" class="h-full bg-yellow-400 transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>

        <div class="flex items-center gap-8 text-right">
            <div class="flex flex-col mr-4">
                <span class="text-[9px] uppercase font-bold text-gray-500 leading-none tracking-widest mb-1">Battalion</span>
                <span id="armySize" class="text-xl font-mono font-bold">01</span>
            </div>
            <div class="flex flex-col">
                <span class="text-[9px] uppercase font-bold text-yellow-500 leading-none tracking-widest mb-1">Total Kills</span>
                <span id="killCount" class="text-2xl font-mono font-black">000</span>
            </div>
            <button onclick="togglePause()" class="pointer-events-auto bg-white/5 p-3 rounded-lg border border-white/10">
                <svg width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A.5.5 0 0 1 6 4v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5zm5 0 a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/></svg>
            </button>
        </div>
    </div>

    <div id="pause-screen" class="modal">
        <h2 class="text-4xl font-black mb-4 uppercase tracking-tighter">Tactical Pause</h2>
        <button onclick="togglePause()" class="bg-blue-600 w-full py-4 rounded-lg font-black tracking-widest hover:bg-blue-500 mb-4">RESUME</button>
    </div>

    <div id="game-over" class="modal">
        <h2 class="text-5xl font-black mb-2 text-red-600 uppercase tracking-tighter">Mission Failed</h2>
        <button onclick="location.reload()" class="bg-red-600 px-12 py-4 rounded-lg font-black hover:bg-red-500 shadow-2xl">REDEPLOY</button>
    </div>

    <div id="win-screen" class="modal">
        <div class="text-yellow-500 font-bold tracking-[0.4em] text-xs mb-4 uppercase">Dominion Established</div>
        <h2 class="text-6xl font-black mb-2 text-white uppercase tracking-tighter">MISSION COMPLETE</h2>
        <p class="mb-8 text-white/50 uppercase tracking-[0.2em] text-sm">Command Alpha Neutralized. The World is Yours.</p>
        <button onclick="location.reload()" class="bg-yellow-600 px-12 py-4 rounded-lg font-black text-black hover:bg-yellow-500 shadow-2xl uppercase">Ascend to Throne</button>
    </div>

    <div id="crosshair"></div>

    <script>
        // --- CONSTANTS ---
        const MAX_HEALTH = 200;
        const INITIAL_LIVES = 3;
        const GRID_SIZE = 160;
        const MAX_PARTICLES = 1000;
        const BOSS_TRIGGER_KILLS = 200;
        const BOSS_MAX_HP = 1500;
        
        // --- GLOBALS ---
        let scene, camera, renderer, player, ground, clock;
        let allies = [], enemies = [], projectiles = [], enemyProjectiles = [], buildings = [], vehicles = [];
        let buildingGrid = new Map();
        let particleMesh, minimapCtx;
        let health = MAX_HEALTH, kills = 0, currentTierIndex = 0, lastRecruitKills = 0, lastHeartKills = 0, lives = INITIAL_LIVES;
        let keys = {}, isGameOver = false, isPaused = true, recoilVal = 0, turboMode = false, lastShotTime = 0;
        let playerInVehicle = null, isDarkMode = false;
        let joystickActive = false, joystickVector = { x: 0, y: 0 };
        const particleData = [];
        const dummy = new THREE.Object3D();
        let audioCtx = null, noiseBuffer = null;
        let boss = null, bossHP = BOSS_MAX_HP, isBossDefeated = false;

        const config = {
            upgrades: [
                { kills: 0, type: 'Soldier', weapon: 'Assault Rifle', speed: 0.3, fireRate: 200, bulletType: 'standard' },
                { kills: 5, type: 'Scout', weapon: 'Submachine Gun', speed: 0.42, fireRate: 80, bulletType: 'smg' },
                { kills: 12, type: 'Grenadier', weapon: 'Grenade Launcher', speed: 0.32, fireRate: 900, bulletType: 'grenade' },
                { kills: 20, type: 'Enforcer', weapon: 'Combat Shotgun', speed: 0.35, fireRate: 800, bulletType: 'shotgun' },
                { kills: 30, type: 'Marksman', weapon: 'Sniper Rifle', speed: 0.28, fireRate: 1200, bulletType: 'sniper' },
                { kills: 45, type: 'Heavy', weapon: 'Rotary Minigun', speed: 0.22, fireRate: 50, bulletType: 'minigun' },
                { kills: 65, type: 'Demolisher', weapon: 'Heavy Cannon', speed: 0.18, fireRate: 1000, bulletType: 'heavy' },
                { kills: 90, type: 'Spec-Ops', weapon: 'High-Vel Railgun', speed: 0.38, fireRate: 1500, bulletType: 'railgun' },
                { kills: 120, type: 'Pilot', weapon: 'Dual Missile Pods', speed: 0.55, fireRate: 250, bulletType: 'missile' },
                { kills: 160, type: 'General', weapon: 'Singularity Beam', speed: 0.42, fireRate: 100, bulletType: 'plasma' }
            ]
        };

        // --- AUDIO ENGINE ---
        function initAudio() { 
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                noiseBuffer = audioCtx.createBuffer(1, 2 * audioCtx.sampleRate, audioCtx.sampleRate);
                const out = noiseBuffer.getChannelData(0);
                for (let i = 0; i < out.length; i++) out[i] = Math.random() * 2 - 1;
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSfx(opt) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(opt.vol || 0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + opt.decay);
            gain.connect(audioCtx.destination);
            let src = opt.noise ? audioCtx.createBufferSource() : audioCtx.createOscillator();
            if (opt.noise) src.buffer = noiseBuffer;
            else { 
                src.type = opt.type || 'sine'; 
                src.frequency.setValueAtTime(opt.freq || 440, now); 
                if(opt.slide) src.frequency.exponentialRampToValueAtTime(opt.slide, now + opt.decay); 
            }
            if (opt.filter) {
                const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = opt.filter;
                src.connect(f); f.connect(gain);
            } else src.connect(gain);
            src.start(); src.stop(now + opt.decay);
        }

        var sounds = {
            standard: () => playSfx({ freq: 400, decay: 0.15, vol: 0.2, type: 'square', filter: 1200 }),
            hit: () => playSfx({ noise: true, decay: 0.2, vol: 0.3, filter: 600 }),
            engine: (speed) => { if(Math.random() > 0.9) playSfx({ freq: 40 + Math.abs(speed)*150, decay: 0.1, vol: 0.05, type: 'sawtooth', filter: 400 }); },
            heal: () => playSfx({ freq: 600, decay: 0.8, vol: 0.3, slide: 1200 }),
            bossShot: () => playSfx({ freq: 80, decay: 0.6, vol: 0.5, type: 'sawtooth', filter: 200 })
        };

        // --- CORE FUNCTIONS ---
        function updateLimbs(unit, speed) {
            if (!unit.userData.limbs) return;
            const { legL, legR, armL, armR } = unit.userData.limbs;
            unit.userData.animState += Math.abs(speed) * 10;
            const swing = Math.sin(unit.userData.animState) * 0.5;
            legL.rotation.x = swing; legR.rotation.x = -swing;
            armL.rotation.x = -swing; armR.rotation.x = swing;
        }

        window.toggleTheme = function() {
            isDarkMode = !isDarkMode;
            document.body.className = isDarkMode ? 'dark-mode' : 'light-mode';
            const icon = document.getElementById('theme-icon');
            if (icon) icon.innerText = isDarkMode ? 'üåô' : '‚òÄÔ∏è';
            const colors = isDarkMode ? { bg: 0x0a0a14, fog: 0x0a0a14, ground: 0x140a1a } : { bg: 0x87ceeb, fog: 0x87ceeb, ground: 0x3d5a3d };
            if (scene) { scene.background.set(colors.bg); scene.fog.color.set(colors.fog); }
            if (ground) ground.material.color.set(colors.ground);
        };

        window.startGame = function() {
            const startScreen = document.getElementById('start-screen');
            if (startScreen) startScreen.style.display = 'none';
            initAudio();
            isPaused = false;
        };

        window.togglePause = function() {
            isPaused = !isPaused;
            const ps = document.getElementById('pause-screen');
            if (ps) ps.style.display = isPaused ? 'block' : 'none';
        };

        window.exitVehicle = function() {
            if (!playerInVehicle) return;
            playerInVehicle.userData.occupied = null;
            const exitPos = playerInVehicle.position.clone(); exitPos.x += 6;
            player.position.copy(exitPos); playerInVehicle = null;
            const eb = document.getElementById('exit-btn'); if(eb) eb.style.display = 'none';
        };

        function getGridKey(x, z) { return `${Math.floor(x / GRID_SIZE)},${Math.floor(z / GRID_SIZE)}`; }

        function checkBuildingCollision(pos, radius) {
            const key = getGridKey(pos.x, pos.z);
            const list = buildingGrid.get(key);
            if (list) {
                for(let b of list) {
                    if (Math.abs(pos.x - b.position.x) < (20 + radius) && Math.abs(pos.z - b.position.z) < (20 + radius) && pos.y < b.userData.maxH) return b;
                }
            }
            return null;
        }

        function createRealisticUnit(color, isEnemy = false) {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color });
            const darkMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const skinMat = new THREE.MeshPhongMaterial({ color: 0xffdbac });
            const torso = new THREE.Mesh(new THREE.BoxBufferGeometry(0.8, 1, 0.5), mat);
            torso.position.y = 0.9; torso.castShadow = true; group.add(torso);
            const vest = new THREE.Mesh(new THREE.BoxBufferGeometry(0.85, 0.6, 0.6), darkMat);
            vest.position.y = 1.0; group.add(vest);
            const pack = new THREE.Mesh(new THREE.BoxBufferGeometry(0.5, 0.7, 0.3), darkMat);
            pack.position.set(0, 1.0, -0.35); group.add(pack);
            const head = new THREE.Mesh(new THREE.BoxBufferGeometry(0.42, 0.42, 0.42), skinMat);
            head.position.y = 1.45; group.add(head);
            const helm = new THREE.Mesh(new THREE.BoxBufferGeometry(0.5, 0.25, 0.5), isEnemy ? new THREE.MeshPhongMaterial({color:0x000000}) : darkMat);
            helm.position.y = 1.6; group.add(helm);
            const limbGeo = new THREE.BoxBufferGeometry(0.28, 0.8, 0.28);
            const legL = new THREE.Mesh(limbGeo, mat); legL.position.set(-0.25, 0.4, 0); group.add(legL);
            const legR = new THREE.Mesh(limbGeo, mat); legR.position.set(0.25, 0.4, 0); group.add(legR);
            const armL = new THREE.Mesh(limbGeo, mat); armL.position.set(-0.55, 1.0, 0); group.add(armL);
            const armR = new THREE.Mesh(limbGeo, mat); armR.position.set(0.55, 1.0, 0); group.add(armR);
            group.userData.limbs = { legL, legR, armL, armR }; group.userData.animState = 0;
            return group;
        }

        function createBossModel() {
            const group = new THREE.Group();
            const darkMat = new THREE.MeshPhongMaterial({color: 0x111111});
            const base = new THREE.Mesh(new THREE.BoxBufferGeometry(12, 4, 15), darkMat); base.position.y = 2; base.castShadow = true; group.add(base);
            const turret = new THREE.Mesh(new THREE.BoxBufferGeometry(8, 3, 8), new THREE.MeshPhongMaterial({color: 0x333333})); turret.position.y = 5.5; group.add(turret);
            const cGeo = new THREE.CylinderBufferGeometry(0.8, 0.8, 12);
            const c1 = new THREE.Mesh(cGeo, darkMat); c1.rotation.x = Math.PI/2; c1.position.set(2, 5.5, 6); group.add(c1);
            const c2 = new THREE.Mesh(cGeo, darkMat); c2.rotation.x = Math.PI/2; c2.position.set(-2, 5.5, 6); group.add(c2);
            group.userData = { hits: 0, maxH: 8, speed: 0.18, attackCooldown: 100 };
            return group;
        }

        function spawnProjectile(startPos, dir, isAlly, isBossBullet = false) {
            const proj = new THREE.Mesh(new THREE.SphereBufferGeometry(isBossBullet ? 0.8 : 0.3, 4, 4), new THREE.MeshBasicMaterial({color: isAlly ? 0x00ffff : (isBossBullet ? 0xff0000 : 0xff7700)}));
            proj.position.copy(startPos); proj.position.y += isBossBullet ? 5.5 : 1.4;
            proj.userData = { velocity: dir.multiplyScalar(isAlly ? 5 : (isBossBullet ? 3.5 : 2.5)), life: 250, isAlly, damage: isBossBullet ? 50 : 40 };
            scene.add(proj);
            if (isAlly) recoilVal = 0.3; else enemyProjectiles.push(proj);
        }

        function takeDamage(amt) {
            if (isGameOver || isPaused || isBossDefeated) return;
            health -= amt; sounds.hit();
            const ov = document.getElementById('damage-overlay'); if (ov) { ov.style.border = '25px solid rgba(255, 0, 0, 0.4)'; setTimeout(() => { if(ov) ov.style.border = '0px solid transparent'; }, 100); }
            if (health <= 0) {
                lives--; const hearts = ["h1", "h2", "h3"]; const h = document.getElementById(hearts[lives]); if(h) h.style.opacity = '0.2';
                if(lives > 0) health = MAX_HEALTH; else { isGameOver = true; document.getElementById('game-over').style.display = 'block'; }
            }
            updateUIBars();
        }

        function handleCombat() {
            if (isPaused || isGameOver || isBossDefeated) return;
            const now = Date.now(); const tier = config.upgrades[currentTierIndex];
            if (now - lastShotTime < tier.fireRate) return;
            let near = boss || null;
            if (!near) enemies.forEach(en => { const dSq = player.position.distanceToSquared(en.position); if (dSq < 250000) near = en; });
            if (near) player.lookAt(near.position.x, player.position.y, near.position.z);
            spawnProjectile(player.position, new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion), true);
            sounds.standard(); lastShotTime = now;
        }

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb); scene.fog = new THREE.Fog(0x87ceeb, 100, 1000);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 8000);
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); document.body.appendChild(renderer.domElement);
            const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(200, 300, 100); scene.add(sun);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            ground = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), new THREE.MeshPhongMaterial({ color: 0x3d5a3d }));
            ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);
            const pGeo = new THREE.SphereBufferGeometry(0.2, 4, 4); const pMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true });
            particleMesh = new THREE.InstancedMesh(pGeo, pMat, MAX_PARTICLES); scene.add(particleMesh);
            createGridCity(); createPlayer();
            for(let i=0; i<3; i++) spawnAlly();
            for(let i=0; i<15; i++) createEnemy();
            clock = new THREE.Clock();
            const mm = document.getElementById('minimap'); if (mm) minimapCtx = mm.getContext('2d');
        }

        function createGridCity() {
            const bMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
            for(let gx = -12; gx <= 12; gx++) {
                for(let gz = -12; gz <= 12; gz++) {
                    if (Math.abs(gx) < 1 && Math.abs(gz) < 1) continue;
                    const h = 40 + Math.random() * 180;
                    const group = new THREE.Group();
                    const b = new THREE.Mesh(new THREE.BoxBufferGeometry(40, h, 40), bMat);
                    b.position.y = h/2; b.castShadow = true; b.receiveShadow = true;
                    b.userData = { hits: 0, maxH: h }; group.add(b);
                    group.position.set(gx * GRID_SIZE, 0, gz * GRID_SIZE);
                    scene.add(group); buildings.push(b);
                    const key = getGridKey(gx * GRID_SIZE, gz * GRID_SIZE);
                    if (!buildingGrid.has(key)) buildingGrid.set(key, []);
                    buildingGrid.get(key).push(b);
                }
            }
        }

        function createPlayer() {
            if (player) scene.remove(player);
            const tier = config.upgrades[currentTierIndex];
            if (tier.type === 'Pilot') {
                player = new THREE.Group();
                const fus = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1, 6), new THREE.MeshPhongMaterial({color: 0x3498db})); fus.rotation.x = Math.PI/2; player.add(fus);
                const wing = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 2), new THREE.MeshPhongMaterial({color: 0x3498db})); player.add(wing);
            } else { player = createRealisticUnit(tier.type === 'General' ? 0xffd700 : 0x3b82f6); }
            player.userData = { yOffset: tier.type === 'Pilot' ? 22 : 0.2, velocity: new THREE.Vector3() };
            scene.add(player);
            const elRank = document.getElementById('rank'); if(elRank) elRank.innerText = tier.type;
            const elWep = document.getElementById('weapon-name'); if(elWep) elWep.innerText = tier.weapon;
        }

        function spawnAlly() {
            const ally = createRealisticUnit(0x0077ff);
            ally.position.set(player.position.x + (Math.random()-0.5)*30, 0, player.position.z - 20);
            ally.userData = { attackCooldown: Math.random()*60, velocity: new THREE.Vector3() };
            scene.add(ally); allies.push(ally);
        }

        function createEnemy() {
            const enemy = createRealisticUnit(0xff3333, true);
            const angle = Math.random()*Math.PI*2, dist = 400 + Math.random()*150;
            enemy.position.set(player.position.x + Math.cos(angle)*dist, 0, player.position.z + Math.sin(angle)*dist);
            enemy.userData = { health: 120, attackCooldown: 100 + Math.random()*100, velocity: new THREE.Vector3() };
            scene.add(enemy); enemies.push(enemy);
        }

        function spawnBoss() {
            if (boss) return;
            boss = createBossModel(); boss.position.set(player.position.x, 0, player.position.z + 400);
            scene.add(boss); document.getElementById('boss-ui').style.display = 'flex';
        }

        function updateMinimap() {
            if (!minimapCtx) return;
            minimapCtx.clearRect(0,0,140,140); minimapCtx.fillStyle = 'rgba(255,255,255,0.05)';
            buildings.forEach(b => { const bx = (b.position.x - player.position.x)*0.03+70, bz = (b.position.z - player.position.z)*0.03+70; if(bx>0 && bx<140 && bz>0 && bz<140) minimapCtx.fillRect(bx-1, bz-1, 2, 2); });
            minimapCtx.fillStyle = '#ff3333'; enemies.forEach(e => { const ex = (e.position.x - player.position.x)*0.03+70, ez = (e.position.z - player.position.z)*0.03+70; if(ex>0 && ex<140 && ez>0 && ez<140) minimapCtx.fillRect(ex-1, ez-1, 2, 2); });
            if(boss) { minimapCtx.fillStyle = '#ff00ff'; const bx = (boss.position.x - player.position.x)*0.03+70, bz = (boss.position.z - player.position.z)*0.03+70; minimapCtx.fillRect(bx-3, bz-3, 6, 6); }
            minimapCtx.fillStyle = '#ffffff'; minimapCtx.beginPath(); minimapCtx.arc(70, 70, 2, 0, Math.PI*2); minimapCtx.fill();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPaused || isGameOver || isBossDefeated) return;
            const dt = clock.getDelta();
            const accel = playerInVehicle ? 0.05 : 0.12, friction = 0.93;
            
            if (!playerInVehicle) {
                const prev = player.position.clone();
                if (keys['KeyW'] || keys['ArrowUp']) player.userData.velocity.z += accel;
                if (keys['KeyS'] || keys['ArrowDown']) player.userData.velocity.z -= accel;
                if (keys['KeyA'] || keys['ArrowLeft']) player.rotation.y += 0.05;
                if (keys['KeyD'] || keys['ArrowRight']) player.rotation.y -= 0.05;
                if (joystickActive) { player.userData.velocity.z -= joystickVector.y * accel * 2.5; player.rotation.y -= joystickVector.x * 0.06; }
                player.userData.velocity.z *= friction; player.translateZ(player.userData.velocity.z);
                if(checkBuildingCollision(player.position, 1.5)) player.position.copy(prev);
                updateLimbs(player, player.userData.velocity.z);
            }
            player.position.y = player.userData.yOffset;

            if (boss) {
                const prevB = boss.position.clone(); boss.lookAt(player.position.x, 0, player.position.z);
                if (boss.position.distanceToSquared(player.position) > 40000) boss.translateZ(0.2);
                if(checkBuildingCollision(boss.position, 8)) boss.position.copy(prevB);
                if (boss.userData.attackCooldown-- <= 0) {
                    const dir = new THREE.Vector3().subVectors(player.position, boss.position).normalize();
                    spawnProjectile(boss.position.clone().add(new THREE.Vector3(3,0,0)), dir.clone(), false, true);
                    spawnProjectile(boss.position.clone().add(new THREE.Vector3(-3,0,0)), dir.clone(), false, true);
                    boss.userData.attackCooldown = 50;
                }
            }

            [projectiles, enemyProjectiles].forEach((list, isAllyList) => {
                for (let i = list.length - 1; i >= 0; i--) {
                    const p = list[i]; p.position.add(p.userData.velocity); p.userData.life--;
                    if(checkBuildingCollision(p.position, 0.5)) { p.userData.life = 0; }
                    if (isAllyList === 0) {
                        if (boss && p.position.distanceToSquared(boss.position) < 144) {
                            bossHP -= p.userData.damage; p.userData.life = 0;
                            const bhb = document.getElementById('bossHealthBar'); if(bhb) bhb.style.width = (bossHP/BOSS_MAX_HP)*100 + '%';
                            if (bossHP <= 0) { scene.remove(boss); boss = null; isBossDefeated = true; document.getElementById('win-screen').style.display = 'block'; }
                        }
                        enemies.forEach((en, idx) => { if (p.userData.life > 0 && p.position.distanceToSquared(en.position) < 64) { en.userData.health -= p.userData.damage; p.userData.life = 0; if (en.userData.health <= 0) { scene.remove(en); enemies.splice(idx, 1); kills++; updateUI(); createEnemy(); } } });
                    } else { if (p.userData.life > 0 && p.position.distanceToSquared(player.position) < 36) { takeDamage(30); p.userData.life = 0; } }
                    if (p.userData.life <= 0) { scene.remove(p); list.splice(i, 1); }
                }
            });

            enemies.forEach(en => {
                const prev = en.position.clone();
                if (en.position.distanceToSquared(player.position) > 1600) { en.lookAt(player.position); en.translateZ(0.28); }
                if(checkBuildingCollision(en.position, 1.5)) en.position.copy(prev);
                updateLimbs(en, 0.2);
                if (en.userData.attackCooldown-- <= 0 && en.position.distanceToSquared(player.position) < 60000) { spawnProjectile(en.position, new THREE.Vector3().subVectors(player.position, en.position).normalize(), false); en.userData.attackCooldown = 140; }
            });

            allies.forEach(al => {
                const prev = al.position.clone(); al.position.lerp(player.position.clone().add(new THREE.Vector3(-12, 0, -18).applyQuaternion(player.quaternion)), 0.06);
                if(checkBuildingCollision(al.position, 1.5)) al.position.copy(prev);
                updateLimbs(al, 0.1);
                let target = boss || null;
                if(!target) enemies.forEach(en => { if (al.position.distanceToSquared(en.position) < 160000) target = en; });
                if (target) { al.lookAt(target.position); if (al.userData.attackCooldown-- <= 0) { spawnProjectile(al.position, new THREE.Vector3().subVectors(target.position, al.position).normalize(), true); al.userData.attackCooldown = 90; } }
            });

            if (turboMode) handleCombat();
            updateMinimap();
            camera.position.lerp(player.position.clone().add(new THREE.Vector3(0, 30, -65).applyQuaternion(player.quaternion)), 0.1);
            camera.lookAt(player.position.x, 5, player.position.z);
            renderer.render(scene, camera);
        }

        function updateUIBars() { 
            const hb = document.getElementById('healthBar'); if (hb) hb.style.width = (health/MAX_HEALTH)*100 + '%'; 
            const ht = document.getElementById('hpText'); if (ht) ht.innerText = Math.round((health/MAX_HEALTH)*100) + '%'; 
        }

        function updateUI() {
            const kc = document.getElementById('killCount'); if (kc) kc.innerText = kills.toString().padStart(3, '0');
            if (kills >= BOSS_TRIGGER_KILLS && !boss && !isBossDefeated) spawnBoss();
            if (kills > 0 && Math.floor(kills / 50) > Math.floor(lastHeartKills / 50)) { if (lives < INITIAL_LIVES) { lives++; sounds.heal(); const hEl = document.getElementById(["h1","h2","h3"][lives-1]); if(hEl) hEl.style.opacity = '1'; } lastHeartKills = kills; }
            if (Math.floor(kills / 8) > Math.floor(lastRecruitKills / 8)) { spawnAlly(); lastRecruitKills = kills; }
            const next = config.upgrades[currentTierIndex + 1]; if (next && kills >= next.kills) { currentTierIndex++; createPlayer(); }
            const cur = config.upgrades[currentTierIndex], nxt = config.upgrades[currentTierIndex+1];
            const xb = document.getElementById('xpBar'); if (xb) xb.style.width = nxt ? ((kills - cur.kills) / (nxt.kills - cur.kills)) * 100 + '%' : '100%';
            updateUIBars();
        }

        document.addEventListener('DOMContentLoaded', () => {
            init();
            window.addEventListener('keydown', e => { keys[e.code] = true; if(e.code === 'Space' || e.code === 'KeyP') togglePause(); if(e.code === 'KeyT') { turboMode = !turboMode; const ti = document.getElementById('turbo-indicator'); if(ti) ti.style.display = turboMode ? 'block' : 'none'; } if(e.code === 'KeyV') exitVehicle(); });
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousedown', handleCombat);
            const jW = document.getElementById('joystick-wrapper'), jK = document.getElementById('joystick-knob');
            const hT = (e) => { e.preventDefault(); const t = e.touches[0], r = jW.getBoundingClientRect(); const dx = t.clientX - (r.left + r.width/2), dy = t.clientY - (r.top + r.height/2); const d = Math.min(60, Math.sqrt(dx*dx + dy*dy)), a = Math.atan2(dy, dx); jK.style.left = `calc(50% + ${Math.cos(a)*d}px)`; jK.style.top = `calc(50% + ${Math.sin(a)*d}px)`; joystickVector = { x: (Math.cos(a)*d)/60, y: (Math.sin(a)*d)/60 }; joystickActive = true; };
            if(jW) { jW.addEventListener('touchstart', hT); jW.addEventListener('touchmove', hT); jW.addEventListener('touchend', () => { jK.style.left = '50%'; jK.style.top = '50%'; joystickActive = false; }); }
            const fb = document.getElementById('fire-btn'); if(fb) fb.addEventListener('touchstart', (e) => { e.preventDefault(); handleCombat(); });
            const tb = document.getElementById('turbo-btn'); if(tb) tb.addEventListener('touchstart', (e) => { e.preventDefault(); turboMode = !turboMode; const ti = document.getElementById('turbo-indicator'); if (ti) ti.style.display = turboMode ? 'block' : 'none'; });
            const eb = document.getElementById('exit-btn'); if(eb) eb.addEventListener('touchstart', (e) => { e.preventDefault(); exitVehicle(); });
            animate(); updateUI();
        });
        window.addEventListener('resize', () => { if(camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });
    </script>
</body>
</html>
